<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder"></script>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <main class="container">
      <header>
        <h1>Universal Sentence Encoder</h1>
        <h2 class="subtitle">Interfaz tipo Q&A</h2>
      </header>

      <!-- <ul>
        <li>1- Se usa modelo de tensorflow 'USE'</li>
        <li>2- Se pre-embebe texto como base</li>
        <li>
          3- Se implementa un sistema de preguntas y respuestas basado en la
          similitud sem√°ntica
        </li>
      </ul> -->

      <section class="description-section">
        <h3>Funcionamiento</h3>
        <div class="feature-list">
          <div class="feature-item">
            <h4>üß† Modelo Universal Sentence Encoder (USE)</h4>
            <p>
              Se utiliza el modelo pre-entrenado de TensorFlow que convierte
              texto en vectores de 512 dimensiones, capturando el significado
              sem√°ntico de las oraciones.
            </p>
            <small class="annotation"
              >üìù El modelo se carga desde CDN y funciona completamente en el
              navegador</small
            >
          </div>

          <div class="feature-item">
            <h4>üìö Base de Conocimiento Pre-embebida</h4>
            <p>
              Se procesa una base de datos de texto predefinida, generando
              embeddings (representaciones vectoriales) para cada fragmento de
              informaci√≥n.
            </p>
            <small class="annotation"
              >‚ö° Los embeddings se calculan una sola vez al cargar la
              p√°gina</small
            >
          </div>

          <div class="feature-item">
            <h4>üîç Sistema de Similitud Sem√°ntica</h4>
            <p>
              Cuando haces una pregunta, se calcula su embedding y se compara
              con todos los embeddings de la base usando similitud coseno para
              encontrar las respuestas m√°s relevantes.
            </p>
            <small class="annotation"
              >üéØ El sistema no busca palabras exactas, sino significado
              similar</small
            >
          </div>

          <div class="feature-item">
            <h4>üìä Ranking de Resultados</h4>
            <p>
              Los resultados se ordenan por puntuaci√≥n de similitud (0-1),
              mostrando las respuestas m√°s relevantes primero.
            </p>
            <small class="annotation"
              >üî¢ Solo se muestran resultados con similitud > 0.5</small
            >
          </div>
        </div>
      </section>

      <form id="controls" action="javascript:void(0);">
        <label for="question-input" class="sr-only"
          >Escribi tus preguntas ac√°</label
        >
        <input
          type="text"
          id="question-input"
          placeholder="Escribi tus preguntas ac√°..."
        />
        <button type="button" id="search-button" class="button">
          Preguntar
        </button>
      </form>

      <section id="result-box" aria-labelledby="results-heading">
        <h2 id="results-heading" class="sr-only">Resultados</h2>
        <p id="initial-msg"></p>
      </section>

      <section aria-labelledby="console-heading">
        <h2 id="console-heading">Consola</h2>
        <div id="log-console"></div>
      </section>
    </main>

    <script>
      const dataset = [
        {
          question: "¬øQu√© es la inteligencia artificial?",
          answer:
            "Es la simulaci√≥n de procesos de inteligencia humana por parte de sistemas inform√°ticos.",
        },
        {
          question: "¬øQu√© es el aprendizaje autom√°tico?",
          answer:
            "Es una rama de la IA que permite a las m√°quinas aprender a partir de datos.",
        },
        {
          question: "¬øQu√© es un modelo de lenguaje?",
          answer:
            "Un modelo de lenguaje es un sistema que predice o genera texto basado en patrones del lenguaje natural.",
        },
      ];

      const App = {
        model: null,
        embeddings: null,
        threshold: 0.5, // umbral de similitud para mostrar resultados
        typingSpeed: 35, // en ms, vamos a simular un typing como streaming de texto

        // Inicializa la app: carga modelo y embebe dataset
        async init() {
          // Carga el modelo Universal Sentence Encoder (USE) desde CDN.
          // Este modelo convierte texto en vectores num√©ricos que capturan el significado,
          // para que podamos comparar "ideas" m√°s que palabras exactas.
          log("üöÄ Cargando modelo...");
          this.model = await use.load();
          log("‚úÖ Modelo cargado.");

          // Genera los embeddings (vectores de significado) para cada pregunta del dataset.
          // Luego los normaliza para que todas las "flechas" tengan el mismo tama√±o,
          // porque lo que importa es la direcci√≥n (el significado), no la longitud.
          log("üß† Embedding del dataset...");
          const questions = dataset.map((q) => q.question);
          const rawEmbeddings = await this.model.embed(questions);
          this.embeddings = this.normalizeEmbeddings(rawEmbeddings);
          rawEmbeddings.dispose();
          log(`‚úÖ Dataset cargado con ${dataset.length} items.`);

          // Habilita el bot√≥n de b√∫squeda s√≥lo cuando todo est√° listo.
          ui.searchButton.disabled = false;
        },
        // Normaliza embeddings por norma L2 (unitarios)
        normalizeEmbeddings(tensor) {
          // Normaliza los vectores para que el c√°lculo de similitud coseno funcione correctamente.
          // Imagin√° cada oraci√≥n como una flecha apuntando en un espacio abstracto.
          // La normalizaci√≥n hace que todas las flechas tengan tama√±o 1,
          // as√≠ s√≥lo comparamos hacia d√≥nde apuntan, es decir, el significado.
          return tf.div(tensor, tf.norm(tensor, 2, 1).expandDims(1));
        },

        async handleQuery(query) {
          // Convierte la pregunta del usuario en un vector que representa su significado.
          const qVec = await this.model.embed([query]);
          // Normaliza este vector para que tenga magnitud 1 (unidad),
          // igual que los vectores del dataset.
          const qNorm = tf.div(qVec, tf.norm(qVec));
          // Calcula la similitud coseno entre el vector de la consulta
          // y cada vector pre-calculado del dataset.
          // Esto es un n√∫mero entre -1 y 1 que indica qu√© tan alineados est√°n los significados.
          // M√°s cercano a 1 = significado muy parecido.
          const similarities = tf.matMul(qNorm, this.embeddings, false, true);
          // Obtiene los valores de similitud como array de n√∫meros.
          const scores = await similarities.data();
          // Limpia la memoria de TensorFlow
          qVec.dispose();
          qNorm.dispose();
          similarities.dispose();
          // Devuelve los puntajes de similitud.
          return scores;
        },

        async runSearch() {
          const query = ui.questionInput.value.trim();
          if (!query) return;

          ui.resultBox.innerHTML = "";
          log(`üìù Pregunta: "${query}"`);

          const scores = await this.handleQuery(query);
          const results = dataset
            .map((item, i) => ({ ...item, score: scores[i] }))
            .filter((r) => r.score > this.threshold)
            .sort((a, b) => b.score - a.score);

          if (results.length === 0) {
            typeWriter(
              ui.resultBox,
              "‚ö†Ô∏è No se encontraron coincidencias relevantes."
            );
          } else {
            typeWriter(
              ui.resultBox,
              results
                .map((r) => `‚úÖ ${r.answer} (score: ${r.score.toFixed(2)})`)
                .join("\n\n")
            );
          }
        },
      };

      const ui = {
        questionInput: document.getElementById("question-input"),
        searchButton: document.getElementById("search-button"),
        resultBox: document.getElementById("initial-msg"),
        logConsole: document.getElementById("log-console"),
      };

      //funciones auxiliares
      function typeWriter(
        element,
        text,
        speed = App.typingSpeed,
        onComplete = null
      ) {
        let i = 0;
        element.innerHTML = "";
        function type() {
          if (i < text.length) {
            element.innerHTML +=
              text.charAt(i) === "\n" ? "<br>" : text.charAt(i);
            i++;
            setTimeout(type, speed);
          } else if (onComplete) {
            onComplete();
          }
        }
        type();
      }

      function log(msg) {
        const logLine = document.createElement("div");
        const time = new Date().toLocaleTimeString();
        logLine.innerHTML = `<span style="color: #888;">[${time}]</span> ${msg}`;
        ui.logConsole.appendChild(logLine);
        ui.logConsole.scrollTop = ui.logConsole.scrollHeight;
      }

      document.addEventListener("DOMContentLoaded", () => {
        App.init();
        ui.searchButton.addEventListener("click", () => App.runSearch());
      });
    </script>
  </body>
</html>
